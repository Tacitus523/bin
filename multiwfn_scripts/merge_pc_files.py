#!/home/lpetersen/miniconda3/envs/kgcnn_new/bin/python
import argparse
from typing import List, Tuple
import numpy as np
import os

from ase import Atoms
from ase.io import read, write
from scipy.spatial.distance import cdist

# Units:
# QM-Geometry: Angstrom --> Bohr
# MM-Geometry: Bohr --> Bohr
# Charge: e --> e
# Potential: Hartree/e --> eV/e (aka Volt)

angstrom_to_bohr = 1.8897259886
hartree_to_ev = 27.211386245988

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Merge Multiwfn ESP output files in .pc format with multiple point-charge files of different types (e.g., CHELPG, MK, RESP)"
    )
    parser.add_argument("multiwfn_input_file", type=str, help="Path to the Multiwfn input file used to generate the .pc file, should contain positions of MM point charges and MM point charge values")
    parser.add_argument("esp_file", type=str, help="Path to the .pc file with ESP data, generated by multiwfn_ESP, contains positions of MM point charges and ESP values caused by QM density")
    parser.add_argument("-g", "--geom", type=str, required=True, help="Path to the .extxyz file with geometries of the QM-region")
    parser.add_argument("-c", "--charges", type=str, nargs='+', required=True, help="List of point-charge files to merge")
    parser.add_argument("-o", "--output_file", type=str, default="merged_esps.extxyz", help="Output .extxyz file with merged ESP data")
    args = parser.parse_args()
    # for key, value in vars(args).items():
    #     print(f"{key}: {value}")
    return args

def read_chunked_file(filename: str) -> Tuple[List[np.ndarray], List[np.ndarray]]:
    """
    Read a file in chunks where each chunk starts with a size indicator.
    Returns a list of numpy arrays for each chunk based on the specified size.
    
    Args:
        filename (str): Path to the file to read
        
    Returns:
        Tuple[List[np.ndarray], List[np.ndarray]]: List of numpy arrays for each chunk, one for positions and one for a property (e.g., charges or ESPs)
    """
    mm_positions: List[np.ndarray] = []
    property_values: List[np.ndarray] = []
    with open(filename, 'r') as file:
        while True:
            # Try to read the chunk size
            size_line = file.readline().strip()
            if not size_line:  # End of file
                break

            chunk_size = int(size_line)

            # Read the specified number of lines
            chunk_data: List[Tuple[float, float, float, float, float]] = []
            for _ in range(chunk_size):
                line = file.readline()
                if not line:  # Unexpected end of file
                    break
                
                line_values = line.strip().split()
                assert len(line_values) == 4, f"Expected 4 values per line, got {len(line_values)}, line: {line_values}"
                chunk_data.append(tuple(map(float, line_values)))
            
            chunk_data: np.ndarray = np.array(chunk_data, dtype=float)
            chunk_xyz = chunk_data[:, :3]
            chunk_property = chunk_data[:, 3]
            mm_positions.append(chunk_xyz)
            property_values.append(chunk_property)

    return mm_positions, property_values

def load_charge_data(charge_file: str) -> Tuple[List[np.ndarray], np.ndarray]:
    charges = []
    with open(charge_file, 'r') as file:
        for row in file:
            charges.append(np.array(row.strip().split(), dtype=float))
    
    total_charges = np.round([np.sum(charge_array) for charge_array in charges], 1)
    return charges, total_charges

def load_qm_geometries(xyz_file: str) -> List[Atoms]:
    qm_atoms = read(xyz_file, index=":")
    # Convert positions from Angstrom to Bohr
    for atoms in qm_atoms:
        atoms.set_positions(atoms.get_positions() * angstrom_to_bohr)
    return qm_atoms

def construct_mm_extxyz(
    mm_positions: List[np.ndarray],
    mm_charges_list: List[np.ndarray],
    esp_values: List[np.ndarray],
) -> List[Atoms]:
    E_elec_list: np.ndarray = calculate_E_elec(esp_values, mm_charges_list)
    mm_atoms_list: List[Atoms] = []
    for i, (pos, mm_charges, esp) in enumerate(zip(mm_positions, mm_charges_list, esp_values)):
        num_mm_atoms = pos.shape[0]
        symbols = ['X'] * num_mm_atoms  # Placeholder element symbol
        mm_atoms = Atoms(symbols=symbols, positions=pos)
        mm_atoms.arrays['mm_charge'] = mm_charges
        mm_atoms.arrays['ESP_charge_density'] = esp
        mm_atoms.info['E_elec_charge_density'] = E_elec_list[i]
        mm_atoms_list.append(mm_atoms)
    return mm_atoms_list

def calculate_esp(
    qm_atoms_list: List[Atoms],
    mm_atoms_list: List[Atoms],
    qm_charge_list: List[np.ndarray],
) -> List[np.ndarray]:
    """Calculate ESP at MM coordinates due to QM charges."""
    esps_list = []
    for qm_atoms, mm_atoms, qm_charges in zip(qm_atoms_list, mm_atoms_list, qm_charge_list):
        qm_coords = qm_atoms.get_positions()  # shape: (n_qm_atoms, 3)
        mm_coords = mm_atoms.get_positions()  # shape: (n_mm_atoms, 3)
        qmmm_distances = cdist(mm_coords, qm_coords)  # shape: (n_mm_atoms, n_qm_atoms)
        esps = np.matmul(1/qmmm_distances, qm_charges) # shape: (n_mm_atoms,1)
        esps_list.append(esps)
    return esps_list

def calculate_E_elec(
    esps_list: List[np.ndarray],
    mm_charge_list: List[np.ndarray],
) -> np.ndarray:
    """Calculate electrostatic interaction energy E_elec = sum_i q_i * V_i"""
    E_elec_list = []
    for esps, mm_charges in zip(esps_list, mm_charge_list):
        E_elec = np.sum(esps * mm_charges)
        E_elec_list.append(E_elec)
    return np.array(E_elec_list)

def merge_esps_into_mm(
    mm_systems: List[Atoms],
    esps: List[np.ndarray],
    E_elec: np.ndarray,
    charge_name: str,
) -> None:
    assert len(esps) == len(mm_systems), f"Number of esps sets for {charge_name} does not match number of MM geometries. Got {len(esps)} esps sets and {len(mm_systems)} MM geometries."
    assert len(E_elec) == len(mm_systems), f"Number of E_elec values does not match number of MM geometries. Got {len(E_elec)} E_elec values and {len(mm_systems)} MM geometries."
    for i, (mm_system, esp_array) in enumerate(zip(mm_systems, esps)):
        assert len(mm_system) == len(esp_array), f"Number of MM atoms does not match number of esps for {charge_name} for geometry index {i}. Got {len(mm_system)} atoms and {len(esp_array)} esps."
        mm_system.arrays[f"ESP_{charge_name}"] = esp_array
        mm_system.info[f"E_elec_{charge_name}"] = E_elec[i]
    
def main(args: argparse.Namespace) -> None:
    mm_positions_in, mm_charges = read_chunked_file(args.multiwfn_input_file)
    mm_positions, esp_values = read_chunked_file(args.esp_file)
    for i, (pos_in, pos_out) in enumerate(zip(mm_positions_in, mm_positions)):
        if not np.allclose(pos_in, pos_out):
            raise ValueError(f"MM positions in {args.multiwfn_input_file} do not match MM positions in {args.esp_file} for geometry index {i}.")

    qm_molecules: List[Atoms] = load_qm_geometries(args.geom)
    mm_systems: List[Atoms] = construct_mm_extxyz(mm_positions, mm_charges, esp_values)

    for charge_file in args.charges:
        charge_name = os.path.splitext(os.path.basename(charge_file))[0]
        qm_charges, total_charges = load_charge_data(charge_file)
        esps = calculate_esp(qm_molecules, mm_systems, qm_charges)
        E_elec = calculate_E_elec(esps, mm_charges)
        merge_esps_into_mm(mm_systems, esps, E_elec, charge_name)

    # convert potentials from Hartree/e to eV/e (Volt)
    for mm_system in mm_systems:
        for key in mm_system.arrays.keys():
            if key.startswith("ESP_"):
                mm_system.arrays[key] *= hartree_to_ev

    print(f"Writing merged data to {args.output_file}...")
    write(args.output_file, mm_systems, format='extxyz')

if __name__ == "__main__":
    args = parse_args()
    main(args)